#ifndef _CEU_MEDIA_MEDIA
#define _CEU_MEDIA_MEDIA

#define NS 1000000
#define FREQ 15

input (_GObject&&, _lp_Event&&) LP_EVENT;

native/pre do
  ##include <glib.h>
  ##include <play.h>
  ##include <stdlib.h>
  
  ##define UNSAFE(x) x
  ##define ELEM_N(V,N) V[N]
  typedef char * charptr;
end

native @plain _charptr;

native @pure _UNSAFE;
native @pure _ELEM_N();

/*********** LibPlay functions *************/
native @nohold _lp_scene_new;
native @nohold _lp_scene_receive;
native @nohold _lp_scene_advance;
native @nohold _lp_media_new;
native @nohold _lp_media_start;
native @nohold _lp_media_stop;
native @nohold _lp_event_get_source;
native @nohold _lp_event_to_string;
native @pure _LP_IS_MEDIA;
native @pure _LP_IS_SCENE;
native @pure _LP_MEDIA;
native @pure _LP_SCENE;
native @pure _LP_EVENT;
native @pure _LP_EVENT_POINTER_CLICK;
native @pure _LP_EVENT_POINTER_MOVE;
native @pure _LP_EVENT_KEY;
native @pure _LP_EVENT_ERROR;

/***********  GLib functions  *************/
native @nohold _g_object_unref;
native @nohold _g_object_set;
native @nohold _g_object_get;
native @pure _G_OBJECT;
native @pure _G_OBJECT_TYPE;

/*********  Library Public API ***********/
data Region with
  var int x;
  var int y;
  var int width;
  var int height;
end

data Size with
  var int width;
  var int height;
end

data Media with
  tag EMPTY;

  or

  tag VIDEO with
    var _char[255] uri;
    var Region region;
    var int z;
    var float alpha;
    var float volume;
  end

  or

  tag IMAGE with
    var _char[255] uri;
    var Region region;
    var int z;
    var float alpha;
  end

  or

  tag AUDIO with
    var _char[255] uri;
    var float volume;
  end 

  or

  tag TEXT with
    var _char[255] uri; 
    var _char[255] font_desc;
    var uint color;
    var Region region;
    var int z;
  end
end

class Scene with
  var Size? size;
  var bool auto_advance;

  /* Scene functions */
  function (uint) => void advance_time;
  function (void) => _lp_Scene && getptr;

  /* Scene events */
  event (f64, f64, int, int) mouse_click_event;
  event (f64, f64) mouse_move_event;
  event (_charptr, int) key_event;
  event (_charptr) error_event;

  event (void) quit;
do
  var int w=0, h=0;
  if this.size? then
    w = this.size!.width;
    h = this.size!.height;
  end

  var _lp_Scene &?scene;
  finalize
    scene = &_lp_scene_new (w, h);
  with
    _g_object_unref (_G_OBJECT(&&scene!));
  end

  _g_object_set (&&scene!, "slave-audio", true, null);
  _g_object_set (&&scene!, "lockstep", true, null);

  spawn do
    async (scene) do
      loop do 
        var _lp_Event &&evt;
        evt = _UNSAFE(_lp_scene_receive (&&scene!, false)); 
        if evt != null then
          emit LP_EVENT => (_UNSAFE(_lp_event_get_source(evt)), evt);
        end
      end
    end
    await FOREVER;
  end

  par/or do
    loop do
      var _GObject &&source;
      var _lp_Event &&evt;
      (source, evt) = await LP_EVENT until (_LP_IS_SCENE(source) and 
                                          _LP_SCENE(source) == &&scene!);
      var _GType type = _G_OBJECT_TYPE (evt);
      if type == _LP_TYPE_EVENT_POINTER_CLICK then
        var _lp_EventPointerClick &&evtPointerClick = 
                                      _UNSAFE(_LP_EVENT_POINTER_CLICK (evt));
        var f64 x = 0, y = 0;
        var int button = 0, press = 0;
        
        _g_object_get (_G_OBJECT(evtPointerClick), "x", &&x, "y", &&y,
                      "button", &&button, "press", &&press, null);
        
        emit mouse_click_event => (x, y, button, press);
      else/if type == _LP_TYPE_EVENT_POINTER_MOVE then
        var _lp_EventPointerMove &&evtPointerMove = 
                                      _UNSAFE(_LP_EVENT_POINTER_MOVE (evt));
        var f64 x = 0, y = 0;
        
        _g_object_get (_G_OBJECT(evtPointerMove), "x", &&x, "y", &&y, null);
        
        emit mouse_move_event => (x, y);
      else/if type == _LP_TYPE_EVENT_KEY then
        var _lp_EventKey &&evtKey = _UNSAFE(_LP_EVENT_KEY(evt));
        var _charptr key = null;
        var int press = 0;
        _g_object_get (_G_OBJECT(evtKey), "key", &&key, 
                                          "press", &&press, null);
        emit key_event => (key, press);

        finalize with
          _g_free (key);
        end
      else/if type == _LP_TYPE_EVENT_ERROR then
        var _lp_EventError &&evtError = _UNSAFE(_LP_EVENT_ERROR(evt));
        var _GError &&err = null;
        var _charptr msg = null;

        _g_object_get (_G_OBJECT(evtError), "error", &&err, null);
        msg = _lp_event_to_string (_LP_EVENT(evtError));

        emit error_event => (msg);

        finalize with
          _g_free (msg);
        end
      end
    end
  with
    if auto_advance == true then 
      every FREQ ms do
        _lp_scene_advance (&&scene!, FREQ * NS);
      end
    else
      await FOREVER;
    end
  with
    await quit;
  end

  escape 0;

  function (void) => _lp_Scene && getptr do
    return &&scene!;
  end

  function (uint value) => void advance_time do
    if auto_advance == false then
      _lp_scene_advance (&&scene!, value);
    end
  end

end

class Player with
  var Scene   &scene;
  var Media   media;

  /* functions */
  function (Media m, Scene &s) => Player play;
  function (Region r) => void set_region_bounds;
  function (int, int, int, int) => void set_bounds;
  function (char && name, float value) => void set_property_float;
  function (char && name, int value) => void set_property_int;
  function (char && name, bool value) => void set_property_bool;
  function (char && name, char && value) => void set_property_char;
  function (char && name) => float get_property_float;
  function (char && name) => int get_property_int;
  function (char && name) => bool get_property_bool;

  /* events */
  event (void) start;
  event (void) stop;
do
  var _charptr value = null;
  if media.VIDEO then
    value = media.VIDEO.uri;
  else/if media.IMAGE then
    value = media.IMAGE.uri;
  else/if media.AUDIO then
    value = media.AUDIO.uri;
  else/if media.TEXT then
    /* nothing to do */
  else
    _assert(media.EMPTY);
    escape 0; // terminates immediately
  end

  var _lp_Media &?m;
    finalize
      m = &_lp_media_new (scene.getptr(), _UNSAFE(value));
    with
      _lp_media_stop (&&m!);
    end

  if media.VIDEO then
    _g_object_set (_G_OBJECT(&&m!), "x", media.VIDEO.region.x, "y", media.VIDEO.region.y,
                  "width", media.VIDEO.region.width, "height", media.VIDEO.region.height,
                  "z", media.VIDEO.z, "alpha", media.VIDEO.alpha,
                  "volume", media.VIDEO.volume, null);
  else/if media.IMAGE then
    _g_object_set (_G_OBJECT(&&m!), "x", media.IMAGE.region.x, "y", media.IMAGE.region.y,
                  "width", media.IMAGE.region.width, "height", media.IMAGE.region.height,
                  "z", media.IMAGE.z, "alpha", media.IMAGE.alpha, null);
  else/if media.AUDIO then
    _g_object_set (_G_OBJECT(&&m!), "volume", media.AUDIO.volume, null);
  else/if media.TEXT then
    _g_object_set (_G_OBJECT(&&m!), "text", media.TEXT.uri,
                  "text-font", media.TEXT.font_desc,
                  "text-color", media.TEXT.color,
                  "x", media.TEXT.region.x, "y", media.TEXT.region.y,
                  "width", media.TEXT.region.width, "height", media.TEXT.region.height,
                  "z", media.TEXT.z,  null);
  end

  _lp_media_start (&&m!);
  loop do
    var _GObject &&source;
    var _lp_Event &&evt;
    (source, evt) = await LP_EVENT 
                  until (_LP_IS_MEDIA(source) and _LP_MEDIA(source) == &&this.m!);
    var _GType type = _G_OBJECT_TYPE (evt);
    if type == _LP_TYPE_EVENT_START then
      emit start;
    else/if type == _LP_TYPE_EVENT_STOP then
      emit stop;
      break;
    end
  end

  escape 0;

  /* function definitions */
  function (Media m, Scene &s) => Player play do
    this.scene = &s;
    this.media = m;
  end

  function (Region r) => void set_region_bounds do
    _g_object_set (&&this.m!, "x", r.x, "y", r.y, 
            "width", r.width, "height", r.height, null);
  end

  function (int x, int y, int width, int height) => void set_bounds do
    _g_object_set (&&this.m!, "x", x, "y", y, 
            "width", width, "height", height, null);
  end
  
  function (char&& name, float value) => void set_property_float do
    _g_object_set (&&this.m!, name, value, null);
  end

  function (char&& name, int value) => void set_property_int do
    _g_object_set (&&this.m!, name, value, null);
  end

  function (char&& name, bool value) => void set_property_bool do
    _g_object_set (&&this.m!, name, value, null);
  end

  function (char&& name, char&& value) => void set_property_char do
    _g_object_set (&&this.m!, name, value, null);
  end

  function (char&& name) => int get_property_int do
    var int value = 0;
    _g_object_get (&&this.m!, name, &&value, null);
    return value;
  end

  function (char&& name) => bool get_property_bool do
    var bool value = false;
    _g_object_get (&&this.m!, name, &&value, null);
    return value;
  end

  function (char&& name) => float get_property_float do
    var float value = 0.0;
    _g_object_get (&&this.m!, name, &&value, null);
    return value;
  end
end

/***********    async clock block   *************/
spawn do
  async do 
    var s64 base, current, tmp;
    base = _g_get_monotonic_time ();
    current = 0;
    tmp = 0;
    loop do
      current = _g_get_monotonic_time ();
      tmp = current - base;
      
      base = current;
      emit (tmp)us;
    end
  end
  await FOREVER;
end

#endif
